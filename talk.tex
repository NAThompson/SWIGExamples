\documentclass{beamer}
\usepackage{listings}
\usepackage{hyperref}
\hypersetup{
colorlinks=true,
urlcolor=blue
}

\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\begin{document}
\title{SWIG}
\author{Nick Thompson} 
\date{\today} 

\frame{\titlepage} 


\begin{frame}[fragile]
\frametitle{Installation}

\begin{lstlisting}[language=bash]
sudo apt-get -y install libpcre3-dev byacc yodl
git clone --depth 1 https://github.com/swig/swig.git
./autogen.sh
./configure --prefix=/place/for/swig # or default: /usr/local/share
make -j8 && make install
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Clone the examples}
  \begin{lstlisting}[language=bash]
    git clone https://github.com/NAThompson/SWIGExamples.git
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Wrapping C is Easy:}
\begin{lstlisting}[language=bash]
  cd wrap_pure_c;
  make
  ./say_hello.py
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Let's try to wrap some C++ without SWIG}
  \begin{lstlisting}[language=bash]
    cd wrap_cpp_wo_swip;
    make
    ./say_hello.py
  \end{lstlisting}
  Name mangling is a pain!
  
  Also, note how much the Python interpreter cares about your private methods!
\end{frame}

\begin{frame}
  \frametitle{Using Mangled Symbols in ctypes is Untenable!}
  Because the C++ type system is richer than ctypes can handle . . . 
\end{frame}

\begin{frame}
  \frametitle{How would \emph{you} design a wrapper script for interfacing Python and C++?}
  \begin{itemize}
    \item C variables are passed by pointer or value.
    \item C++ variables can be pass by pointer, value, reference, and rvalue reference, and const qualified to your heart's delight.
    \item Python variables are passed by assignment (creation of references)
  \end{itemize}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Design of SWIG: Hammer the C++ into C code the Python interpreter cam use}
  \begin{itemize}
  \item Everything in Python is treated by the Python interpreter as a PyObject.
  \item A PyObject ``is a type which contains the information Python needs to a pointer to an object as an object''.
  \item So if we want to wrap a $\texttt{bool foo()}$, we create a new function returning $\texttt{PyObject}$ of type $\texttt{Py\_True}$ or $\texttt{Py\_False}$ . . . which are themselves PyObject*.
  \item Generate code that we can use $\texttt{extern ``C''}$ on; build a Python extension module.
  \item Will it work with Jython? (methinks no . . .)
  \end{itemize}
\end{frame}


\begin{frame}[fragile]
  \frametitle{SWIG Minimal Working Example}
  \begin{lstlisting}[language=bash]
    cd swig_mwe;
    swig_mwe$ make
    swig_mwe$ python3
    >>> import is_even
    >>> dir(is_even)
    ['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_is_even', '_newclass', '_object', '_swig_getattr', '_swig_getattr_nondynamic', '_swig_property', '_swig_repr', '_swig_setattr', '_swig_setattr_nondynamic', 'is_even']
    >>> is_even.is_even(5)
    False
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Deep Mystery}
  Why can we only call globally defined symbols from a shared object, and not locally defined symbols?
  \begin{lstlisting}[language=bash]
    swig_mwe$ nm _is_even.so | grep ``_wrap_is_even \|_init_''
    00000000000020c0 T _init
    000000000000629c t _wrap_is_even
    swig_mwe$ python3 -q
    >>> import os
    >>> from ctypes import cdll
    >>> so = cdll.LoadLibrary(os.path.join(os.getcwd(), ``_is_even.so'')))
    >>> is_even = so._wrap_is_even
    Symbol not found
    >>> foo = so._init
  \end{lstlisting}
\end{frame}



\begin{frame}[fragile]
  \frametitle{SWIG And C++ namespaces}
  \begin{lstlisting}[language=bash]
    cd swig_namespace;
    swig_namespace$ make
    swig_namespace$ python3
    >>> import is_even
    >>> dir(is_even)
    ['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_is_even', '_newclass', '_object', '_swig      _getattr', '_swig_getattr_nondynamic', '_swig_property', '_swig_repr', '_swig_setattr', '_swig_setattr_nondynamic', 'is_even']
    >>> is_even.is_even(5)
    False
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{SWIG and a C++ namespace clash}
  ``If your program utilizes thousands of small deeply nested namespaces each with identical symbol names, well, then
  you get what you deserve.`` --Swig documentation
  \begin{lstlisting}[language=bash]
    cd swig_namespace_clash
    swig_namespace_clash$ make
    swig_namespace_clash$ python3 -q
    >>> import is_even
    >>> dir(is_even)
    ['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_is_even', '_newclass', '_object', '_swig_getattr', '_swig_getattr_nondynamic', '_swig_property', '_swig_repr', '_swig_setattr', '_swig_setattr_nondynamic', 'bar_is_even', 'foo_is_even']
    >>> is_even.bar_is_even(4)
    True
    >>> is_even.foo_is_even(4)
    True
   \end{lstlisting}
\end{frame}


\begin{frame}[fragile]
  \frametitle{How to wrap C++ templates}

  Python doesn't use templates; nor does C. C++ templates are turned into assembly code at compile time, iff there exists a template instantiation.

  So you must instantiate the templates to interface C++ and Python.

  \begin{lstlisting}[language=bash]
    cd swig_vector;
    make
  \end{lstlisting}

\end{frame}

\end{document}
